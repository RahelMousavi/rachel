import sys

def prim(cost, n): # ماتریس هزینه و تعداد راس های گراف
    # 1. تعریف متغیرهای اولیه
    INF = sys.maxsize  #  مقدار بی‌نهایت برای وزن‌های نامحدود برای  شبیه‌سازی "عدم اتصال" بین رأس‌ها
    s = [0] * n        # لیست نشان‌دهنده رأس‌های انتخاب شده
    near = [0] * n     # نزدیک‌ترین رأس به هر رأس
    mindist = [0] * n  # کمترین فاصله ی راس های انتخاب نشده تا درخت پوشا
    T = []             # لیست یال‌های درخت پوشا
    mincost = 0        # هزینه کل درخت پوشا

    # 2. مقداردهی اولیه
    s[0] = 1           # شروع از رأس 0. یعنی راس صفر انتخاب شده.
    near[0] = -1       #  نشان‌دهنده عدم وجود رأس نزدیک به راس صفر چون هنوز راس دیگری انتخاب نشده.
    mindist[0] = INF   # فاصله رأس شروع تا خودش بی‌نهایت است

    # 3. مقداردهی اولیه برای رأس‌های دیگر
    for i in range(1, n):
        near[i] = 0    #  نزدیک‌ترین رأس به هر رأس، رأس 0 است چون هنوز راس دیگری انتخاب نشده.
        mindist[i] = cost[i][0]  # "فاصله هر رأس i از درخت موقت را برابر با وزن یال بین آن رأس و رأس شروع (رأس ۰) قرار بده." وزن همه ی گره ها به راس صفر نسبت داده میشود.

    # 4. ساخت درخت پوشا با n-1 یال
    for _ in range(n-1):
        # یال با کمترین وزن را که یک رأس جدید را به درخت پوشا متصل می‌کند، پیدا می‌کند.
        min_edge = INF # چون میخواهیم مینیمم پیدا کنیم در ابتدا یک مقدار بزرگ به آن نسبت می دهیم.
        j = -1 # مقدار پیش‌فرض اندیس رأس جدیدی که قرار است به درخت اضافه شود (نشانی از عدم انتخاب)
        for k in range(n): #s[k]: نشان میدهد که آیا راس k (0) قبلا به درخت اضافه شده یا نه.
            if s[k] == 0 and mindist[k] < min_edge: #mindist[k]: کمترین فاصله شناخته‌شده از رأس k به درخت.
                min_edge = mindist[k] #min_edge: کمترین فاصله یافت‌شده در هر مرحله (مقدار اولیه: ∞).
                j = k #j: اندیس رأس جدیدی که قرار است به درخت اضافه شود.

        #  رأس جدید انتخاب شده (j) را به درخت پوشا اضافه می‌کند و اطلاعات را به‌روز می‌کند
        T.append((j, near[j])) #j: رأس جدیدی که قرار است به درخت اضافه شود. near[j]: رأس موجود در درخت که نزدیک‌ترین به j است.
        s[j] = 1 #آرایه s  نشان می‌دهد کدام رأس‌ها قبلاً در درخت هستند مقدار 1 یعنی این رأس دیگر نباید در مراحل بعدی انتخاب شود
        mincost += cost[j][near[j]] #وزن یالی که j را به near[j] وصل می‌کند که تازه اضافه شده را به هزینه کل درخت اضافه می‌کند.


        # فاصله رأس‌های خارج درخت را از درخت پوشا به‌روز می‌کند
        for L in range(n):
            if s[L] == 0 and cost[L][j] < mindist[L]: # برای هر راس L که هنوز در درخت نیست اگر وزن یال بین L,j (راس جدید اضافه شده) کمتر از فاصله ی راس L تا راسی که الان بهش وصله باشد.
                mindist[L] = cost[L][j] # فاصله کمینه را به‌روز کن
                near[L] = j # نزدیک ترین راس در درخت به L را j قرار بده

    return mincost, T

# مثال اجرا:
n = 3
INF = sys.maxsize
cost = [
    [0, 2, 3], # cost[0(اولین عنصر لیست که خودش لیست است)][0(اولین عنصر اولین لیست لیست)] =  (مقدارش صفر است چون وزن یال بین راس صفر وصفر برابر صفر است)
    [2, 0, 1], # cost[1][2] = 1
    [3, 1, 0]  # cost[2][0] = 3 (وزن یال بین راس دوم و صفر برابر 3 است)
]

min_cost, mst_edges = prim(cost, n)
print("هزینه کل:", min_cost)
print("یال‌های درخت پوشا:", mst_edges)